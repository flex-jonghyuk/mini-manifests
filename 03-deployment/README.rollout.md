# **rollout**

롤아웃(rollout)은 소프트웨어의 새로운 버전이나 업데이트를 점진적으로 배포하는 과정을 말합니다. 롤아웃은 서비스 중단을 최소화하면서 새로운 버전을 안전하게 배포하기 위해 사용되는 전략입니다.

Kubernetes에서의 롤아웃은 Deployment, DaemonSet, StatefulSet 등의 리소스에서 새로운 버전의 애플리케이션을 배포하는데 사용됩니다. 예를 들어, Deployment의 새로운 버전을 롤아웃하면, Kubernetes는 설정된 업데이트 전략에 따라 새로운 버전의 Pod를 시작하고 이전 버전의 Pod를 종료합니다.

이 과정에서 롤아웃은 다음과 같은 장점을 제공합니다:

- **점진적인 업데이트**: 롤아웃은 새로운 버전을 점진적으로 배포하여, 전체 시스템에 대한 영향을 최소화합니다. 만약 새로운 버전에 문제가 발생하면, 롤아웃을 중지하거나 이전 버전으로 되돌릴 수 있습니다.

- **서비스 중단 최소화**: 롤아웃은 이전 버전의 Pod를 종료하기 전에 새로운 버전의 Pod를 시작하여, 서비스 중단을 최소화합니다.

- **버전 관리**: 롤아웃은 여러 버전의 애플리케이션을 관리하는 데 도움이 됩니다. 롤아웃 히스토리를 조회하여 각 롤아웃의 상태를 확인할 수 있습니다.

Kubernetes의 `kubectl rollout` 명령어를 사용하면, 롤아웃의 상태를 확인하거나 롤아웃을 제어하는 등의 작업을 수행할 수 있습니다.

`kubectl rollout` 명령어는 Kubernetes의 Deployment, DaemonSet, StatefulSet과 같은 리소스에 대해 버전 관리를 수행하는데 사용됩니다. 이러한 리소스들은 업데이트를 롤아웃하는 메커니즘을 가지고 있으므로, 이를 통해 새로운 버전으로 업데이트하거나 이전 버전으로 되돌릴 수 있습니다.

`kubectl rollout` 명령어는 다음과 같은 하위 명령어를 포함합니다:

- `kubectl rollout status`: 롤아웃 상태를 확인합니다.
- `kubectl rollout history`: 롤아웃의 히스토리를 조회합니다.
- `kubectl rollout undo`: 이전 버전으로 롤아웃을 되돌립니다.
- `kubectl rollout pause`: 롤아웃을 일시 중지합니다.
- `kubectl rollout resume`: 일시 중지된 롤아웃을 재개합니다.
- `kubectl rollout restart`: 롤아웃을 재시작합니다.

이 명령어들을 사용하면, Kubernetes 리소스의 업데이트를 더욱 안전하고 효과적으로 관리할 수 있습니다.

## 롤아웃 배포 과정

롤아웃 배포 과정은 크게 다음과 같이 진행됩니다:

1. 먼저, Docker 이미지를 변경하려면 Dockerfile을 업데이트하고 새 버전의 Docker 이미지를 빌드하고 푸시해야 합니다. 이는 로컬 시스템에서 수행하거나, CI/CD 파이프라인을 사용할 수도 있습니다.

2. 그 다음, Deployment 매니페스트의 `image` 필드를 새 Docker 이미지의 이름으로 변경합니다. 이렇게 하면 Kubernetes는 이 이미지를 사용하여 새 버전의 Pod를 생성하게 됩니다.

3. 이제 `kubectl apply -f deployment.yaml` 명령을 실행하여 변경된 매니페스트를 적용하면 됩니다. 이 명령은 Deployment 매니페스트에 정의된 바와 같이 Kubernetes에게 새 버전의 롤아웃을 시작하도록 지시합니다.

4. 이후 Kubernetes는 설정된 업데이트 전략(`RollingUpdate` 또는 `Recreate`)에 따라 새 버전의 롤아웃을 진행합니다. `RollingUpdate` 전략을 사용하는 경우, Kubernetes는 새 버전의 Pod를 하나씩 생성하고 준비 상태가 되면 이전 버전의 Pod를 하나씩 제거합니다. 이 과정은 새 버전의 모든 Pod가 준비 상태가 될 때까지 계속됩니다.

5. 롤아웃이 완료되면, `kubectl rollout status deployment/<deployment-name>` 명령을 실행하여 롤아웃 상태를 확인할 수 있습니다. 이 명령은 롤아웃이 성공적으로 완료되었는지, 아니면 문제가 있는지를 알려줍니다.

이와 같이, Docker 이미지를 변경하려면 Deployment 매니페스트를 업데이트하고 `kubectl apply`를 실행하면 됩니다. 이것이 Kubernetes의 기본적인 롤아웃 메커니즘이며, 이를 통해 애플리케이션의 새 버전을 배포할 수 있습니다.

## 블루/그린 배포와 롤아웃의 차이점

롤아웃은 Kubernetes Deployment에서 제공하는 업데이트 메커니즘으로, 애플리케이션의 새 버전을 점진적으로 배포하는 것을 의미합니다. 롤아웃 동안 Kubernetes는 새로운 버전의 파드를 생성하고, 이전 버전의 파드를 종료합니다.

블루/그린 배포와 롤아웃은 유사하게 들릴 수 있지만, 둘은 배포 전략 측면에서 몇 가지 중요한 차이점이 있습니다.

블루/그린 배포 전략은 동시에 두 개의 동일한 프로덕션 환경을 유지하고, 한 환경(블루)에는 현재 버전의 애플리케이션을, 다른 환경(그린)에는 새 버전의 애플리케이션을 배포합니다. 두 환경은 완전히 별도로 운영되며, 새 버전이 문제없이 작동하는 것을 확인한 후에 트래픽을 새로운 환경으로 전환합니다. 이 방식은 롤백이 쉽고, 배포 중에 발생할 수 있는 서비스 중단을 최소화합니다.

한편, 롤아웃 전략은 한 환경 내에서 이루어집니다. 새 버전의 파드를 생성하면서 동시에 이전 버전의 파드를 점진적으로 종료합니다. 롤아웃 도중에 문제가 발생하면 롤백을 수행하면 되지만, 이는 블루/그린 배포 방식보다 복잡할 수 있습니다.

서비스 중단은 여러 가지 이유로 발생할 수 있습니다. 예를 들어, 새로운 파드가 아직 시작되지 않았는데 이전 파드가 종료되면 트래픽을 처리할 파드가 없어져서 서비스 중단이 발생할 수 있습니다. 또는 새로운 버전의 애플리케이션이 예상대로 작동하지 않으면 사용자가 서비스 중단을 경험할 수 있습니다. 이런 문제들을 최소화하려면 적절한 롤아웃 전략을 선택하고, 적절한 헬스 체크와 롤백 메커니즘을 구현해야 합니다.

## graceful shutdown

서버가 정상적으로 재시작될 수 있도록 처리 중인 작업이 완료될 때까지 기다리는 것을 말합니다. 그레이스플 셧다운을 사용하면 서비스의 중단을 최소화하면서 새로운 설정이나 업데이트를 적용할 수 있습니다.

그러나 Kubernetes에서는 그레이스플 셧다운을 직접 수행하는 방법은 제공하지 않습니다. 대신 Kubernetes는 Pod의 종료 과정을 제어하는 메커니즘을 제공합니다.

Pod가 종료될 때 Kubernetes는 Pod에게 SIGTERM 시그널을 보냅니다. 이 시그널을 받은 애플리케이션이라면, 종료하기 전에 마무리 작업을 수행할 수 있습니다. 예를 들어, 웹 서버라면 현재 처리 중인 요청을 완료하고 새로운 요청을 받지 않도록 할 수 있습니다.

그런 다음 Kubernetes는 설정된 grace period(기본값은 30초)를 기다립니다. 이 시간 동안에도 Pod가 종료되지 않으면, SIGKILL 시그널을 보내어 Pod를 강제로 종료합니다.

따라서 Kubernetes에서 그레이스플 셧다운과 유사한 작업을 수행하려면, 애플리케이션이 SIGTERM 시그널을 적절히 처리하도록 구현해야 합니다. 또한 필요한 경우 grace period를 조절하여 애플리케이션에 충분한 시간을 주는 것도 중요합니다.

`terminationGracePeriodSeconds` 필드를 통해 Pod 스펙에서 grace period를 설정할 수 있습니다. 이 값은 Pod가 종료 신호를 받은 후 종료되기 전에 기다려야 하는 시간(초)을 정의합니다.

예를 들어, Pod가 종료 신호를 받은 후 60초 동안 기다리도록 설정하려면 다음과 같이 설정할 수 있습니다:

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: my-pod
spec:
  terminationGracePeriodSeconds: 60
  containers:
    - name: my-container
      image: my-image
```

위 예제에서, Kubernetes는 SIGTERM 시그널을 Pod에 보낸 후 60초 동안 기다립니다. 이 시간 동안에도 Pod가 종료되지 않으면, SIGKILL 시그널을 보내어 Pod를 강제로 종료합니다.

`terminationGracePeriodSeconds` 필드가 명시적으로 설정되지 않으면, Kubernetes는 기본값인 30초를 사용합니다.

## nodejs에서 graceful shutdown

Node.js와 Express 애플리케이션에서 그레이스풀 리스타트를 구현하려면, 먼저 SIGTERM 시그널을 처리하는 코드를 추가해야 합니다.

다음은 SIGTERM 시그널을 받았을 때, 현재 처리 중인 모든 요청을 완료한 후에 서버를 종료하는 예제입니다:

```javascript
const express = require("express");
const app = express();

// 예제 서버 코드
app.get("/", (req, res) => res.send("Hello World!"));
const server = app.listen(3000, () =>
  console.log("Example app listening on port 3000!")
);

process.on("SIGTERM", () => {
  console.log("SIGTERM signal received: closing HTTP server");
  server.close(() => {
    console.log("HTTP server closed");
  });
});
```

위 코드에서 `process.on('SIGTERM', ...)` 부분은 SIGTERM 시그널을 받으면 실행되는 핸들러를 등록하는 코드입니다. SIGTERM 시그널을 받으면, `server.close()`를 호출하여 현재 처리 중인 요청을 모두 완료한 후에 서버를 종료하도록 합니다.

이렇게 하면 Kubernetes가 Pod를 종료하려고 할 때, 애플리케이션은 SIGTERM 시그널을 받고 현재 처리 중인 요청을 완료한 후에 종료하게 됩니다. 이로 인해 사용자에게 서비스 중단을 최소화할 수 있습니다.

그러나 이 방법은 애플리케이션이 요청을 빠르게 처리할 수 있을 때만 효과적입니다. 만약 애플리케이션이 종료하기 전에 오랜 시간이 걸리는 요청을 처리해야 한다면, `terminationGracePeriodSeconds`를 적절하게 설정하여 애플리케이션이 충분한 시간을 가질 수 있도록 해야 합니다.

## 롤아웃을 하는 상황에서 graceful shutdown이 안 되어 있을 때 배포시 서비스 중단

이해를 돕기 위해 간단한 예시로 배포 과정을 설명하겠습니다. 가정해볼 것은, 3개의 replica를 가진 배포가 있고, 우리는 이 배포의 새로운 버전을 롤아웃하려고 한다는 것입니다.

1. 새로운 버전의 롤아웃을 시작하면, 먼저 Kubernetes는 새 버전의 Pod를 하나 생성합니다.

2. 새 Pod가 준비 상태(readiness)를 표시하면, 이전 버전의 Pod 하나를 종료합니다. 이 시점에서는 이전 버전의 Pod 두 개와 새 버전의 Pod 하나가 동시에 실행 중입니다.

3. 다음으로, Kubernetes는 두 번째 새 버전의 Pod를 생성하고, 준비 상태를 표시하면 이전 버전의 두 번째 Pod를 종료합니다.

4. 이 과정이 끝나면, Kubernetes는 세 번째(마지막) 새 버전의 Pod를 생성하고, 준비 상태를 표시하면 이전 버전의 마지막 Pod를 종료합니다.

이러한 방식으로 롤아웃을 하면, 새 버전의 Pod가 준비 상태를 표시하기 전에 이전 버전의 Pod를 종료하지 않으므로, 서비스 중단을 최소화할 수 있습니다.

그러나 앞서 말한 것처럼, 이 방식이 효과적이려면 새 버전의 Pod가 실제로 준비 상태를 표시할 수 있어야 합니다. 즉, 애플리케이션은 헬스 체크를 통과하고, 새로운 트래픽을 처리할 수 있어야 합니다. 또한 이전 버전의 Pod는 SIGTERM 시그널을 받아도 바로 종료되지 않고, 현재 처리 중인 요청을 모두 완료한 후에 종료되어야 합니다. 이렇게 하지 않으면, 새 버전의 Pod가 아직 준비되지 않은 상태에서 이전 버전의 Pod가 종료되어, 서비스 중단이 발생할 수 있습니다. 이런 이유로, 애플리케이션이 그레이스풀 셧다운을 지원하도록 구현하는 것이 중요합니다.
